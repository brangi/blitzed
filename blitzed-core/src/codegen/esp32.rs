//! ESP32-specific code generator

use super::{CodeGenerator, GeneratedCode};
use crate::{Model, Result};
use std::path::Path;

/// ESP32 code generator
pub struct Esp32CodeGen;

impl Esp32CodeGen {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for Esp32CodeGen {
    fn generate(&self, model: &Model, output_dir: &Path) -> Result<GeneratedCode> {
        std::fs::create_dir_all(output_dir)?;

        let main_content = format!(r#"// Generated by Blitzed v{}
// ESP32 model deployment

#include <stdio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <esp_log.h>
#include <esp_timer.h>
#include "blitzed_model.h"

static const char* TAG = "blitzed_model";

void inference_task(void* params) {{
    model_input_t* input = (model_input_t*)malloc(MODEL_INPUT_SIZE * sizeof(model_input_t));
    model_output_t* output = (model_output_t*)malloc(MODEL_OUTPUT_SIZE * sizeof(model_output_t));
    
    if (!input || !output) {{
        ESP_LOGE(TAG, "Failed to allocate memory for inference");
        vTaskDelete(NULL);
        return;
    }}

    while (1) {{
        // Generate sample input
        for (int i = 0; i < MODEL_INPUT_SIZE; i++) {{
            input[i] = (model_input_t)(esp_random() % 256 - 128);
        }}

        ESP_LOGI(TAG, "Running inference...");
        int64_t start_time = esp_timer_get_time();
        
        int result = model_predict(input, output);
        
        int64_t duration = esp_timer_get_time() - start_time;
        
        if (result == 0) {{
            ESP_LOGI(TAG, "Inference completed in %lld Î¼s", duration);
            ESP_LOGI(TAG, "Top output: %d", output[0]);
        }} else {{
            ESP_LOGE(TAG, "Inference failed");
        }}
        
        vTaskDelay(pdMS_TO_TICKS(5000)); // Wait 5 seconds
    }}
    
    free(input);
    free(output);
    vTaskDelete(NULL);
}}

void app_main() {{
    ESP_LOGI(TAG, "Blitzed Model on ESP32");
    
    if (model_init() != 0) {{
        ESP_LOGE(TAG, "Model initialization failed");
        return;
    }}
    
    ESP_LOGI(TAG, "Model initialized successfully");
    
    // Create inference task
    xTaskCreate(inference_task, "inference", 8192, NULL, 5, NULL);
}}
"#, crate::VERSION);

        let cmake_content = format!(r#"# Generated by Blitzed v{}
# ESP32 CMakeLists.txt

cmake_minimum_required(VERSION 3.5)

include($ENV{{IDF_PATH}}/tools/cmake/project.cmake)
project(blitzed_model)
"#, crate::VERSION);

        let main_path = output_dir.join("main.c");
        let cmake_path = output_dir.join("CMakeLists.txt");
        
        std::fs::write(&main_path, &main_content)?;
        std::fs::write(&cmake_path, &cmake_content)?;

        Ok(GeneratedCode {
            implementation_file: main_content,
            header_file: None,
            example_file: Some(main_path.to_string_lossy().to_string()),
            build_config: Some(cmake_path.to_string_lossy().to_string()),
            dependencies: vec!["ESP-IDF".to_string()],
        })
    }

    fn target_name(&self) -> &str {
        "esp32"
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["ESP-IDF".to_string()]
    }
}

impl Default for Esp32CodeGen {
    fn default() -> Self {
        Self::new()
    }
}
// Copyright 2025 Gibran Rodriguez <brangi000@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! STM32-specific code generator

use super::{CodeGenerator, GeneratedCode};
use crate::{Model, Result};
use std::path::Path;

/// STM32 code generator that wraps the C code generator with STM32-specific features
pub struct Stm32CodeGen {
    c_generator: super::c::CCodeGen,
}

impl Stm32CodeGen {
    #[must_use]
    pub fn new() -> Self {
        Self {
            c_generator: super::c::CCodeGen::with_target("stm32"),
        }
    }
}

impl CodeGenerator for Stm32CodeGen {
    fn generate(&self, model: &Model, output_dir: &Path) -> Result<GeneratedCode> {
        std::fs::create_dir_all(output_dir)?;

        // First, generate the C code using the C generator
        let c_result = self.c_generator.generate(model, output_dir)?;

        // Generate STM32-specific main.c file
        let main_content = format!(
            r#"// Generated by Blitzed v{}
// STM32 model deployment

#include "blitzed_model.h"
#include "stm32f4xx_hal.h"

// UART handle for debugging output
UART_HandleTypeDef huart2;

// System Clock Configuration (adjust for your STM32)
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_USART2_UART_Init(void);

// Helper function for printf via UART
int _write(int file, char *ptr, int len) {{
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}}

int main(void) {{
    // Initialize HAL
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    
    printf("Blitzed Model on STM32\r\n");
    
    // Initialize the model
    if (model_init() != 0) {{
        printf("Error: Model initialization failed\r\n");
        Error_Handler();
    }}
    
    printf("Model initialized successfully\r\n");
    printf("Model input size: %d\r\n", MODEL_INPUT_SIZE);
    printf("Model output size: %d\r\n", MODEL_OUTPUT_SIZE);
    
    // Main inference loop
    while (1) {{
        run_inference();
        HAL_Delay(5000); // 5 second delay
    }}
}}

void run_inference(void) {{
    model_input_t input[MODEL_INPUT_SIZE];
    model_output_t output[MODEL_OUTPUT_SIZE];
    
    // Generate sample input data (replace with real sensor data)
    for (int i = 0; i < MODEL_INPUT_SIZE; i++) {{
        input[i] = (model_input_t)((i * 17 + 42) % 256 - 128);
    }}
    
    printf("Running inference...\r\n");
    uint32_t start_time = HAL_GetTick();
    
    if (model_predict(input, output) == 0) {{
        uint32_t duration = HAL_GetTick() - start_time;
        printf("Inference completed in %lu ms\r\n", duration);
        
        // Print results
        printf("Results: ");
        for (int i = 0; i < MODEL_OUTPUT_SIZE; i++) {{
            printf("%d ", output[i]);
        }}
        printf("\r\n");
    }} else {{
        printf("Inference failed\r\n");
    }}
}}

// System Clock Configuration
void SystemClock_Config(void) {{
    RCC_OscInitTypeDef RCC_OscInitStruct = {{0}};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {{0}};
    
    __HAL_RCC_PWR_CLK_ENABLE();
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
    
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 16;
    RCC_OscInitStruct.PLL.PLLN = 336;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
    RCC_OscInitStruct.PLL.PLLQ = 4;
    
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {{
        Error_Handler();
    }}
    
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {{
        Error_Handler();
    }}
}}

// GPIO Initialization
void MX_GPIO_Init(void) {{
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOH_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
}}

// USART2 Initialization
void MX_USART2_UART_Init(void) {{
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart2.Init.OverSampling = UART_OVERSAMPLING_16;
    
    if (HAL_UART_Init(&huart2) != HAL_OK) {{
        Error_Handler();
    }}
}}

// Error Handler
void Error_Handler(void) {{
    __disable_irq();
    while (1) {{
        // Stay here
    }}
}}

#ifdef USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line) {{
    printf("Wrong parameters value: file %s on line %lu\r\n", file, line);
}}
#endif
"#,
            crate::VERSION
        );

        let main_path = output_dir.join("main.c");
        std::fs::write(&main_path, &main_content)?;

        // Return both C files and STM32 main file
        Ok(GeneratedCode {
            implementation_file: c_result.implementation_file,
            header_file: c_result.header_file,
            example_file: Some(main_path.to_string_lossy().to_string()),
            build_config: c_result.build_config, // Use Makefile from C generator
            dependencies: vec![
                "arm-none-eabi-gcc".to_string(),
                "STM32CubeF4 HAL".to_string(),
                "make".to_string(),
            ],
        })
    }

    fn target_name(&self) -> &'static str {
        "stm32"
    }

    fn dependencies(&self) -> Vec<String> {
        vec![
            "arm-none-eabi-gcc".to_string(),
            "STM32CubeF4 HAL".to_string(),
            "make".to_string(),
        ]
    }
}

impl Default for Stm32CodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::{Model, ModelData, ModelFormat, ModelInfo};
    use crate::targets::HardwareTarget;
    use tempfile::TempDir;

    fn create_test_model() -> Model {
        let info = ModelInfo {
            format: ModelFormat::Onnx,
            input_shapes: vec![vec![1, 16]], // Moderate input size for STM32
            output_shapes: vec![vec![1, 4]], // Multi-class classification
            parameter_count: 5_000,          // Medium model size
            model_size_bytes: 20_000,        // 20KB - fits in STM32
            operations_count: 2_500,         // Moderate operations
            layers: vec![],                  // Empty for test
        };

        Model {
            info,
            data: ModelData::Raw(vec![0u8; 20_000]),
        }
    }

    #[test]
    fn test_stm32_codegen_creation() {
        let codegen = Stm32CodeGen::new();
        assert_eq!(codegen.target_name(), "stm32");
        assert!(codegen
            .dependencies()
            .contains(&"arm-none-eabi-gcc".to_string()));
        assert!(codegen
            .dependencies()
            .contains(&"STM32CubeF4 HAL".to_string()));
    }

    #[test]
    fn test_stm32_code_generation() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("stm32_output");

        let model = create_test_model();
        let codegen = Stm32CodeGen::new();
        let result = codegen.generate(&model, &output_dir).unwrap();

        // Should have C implementation and header files
        assert!(result.header_file.is_some());
        let header_content = std::fs::read_to_string(result.header_file.as_ref().unwrap()).unwrap();
        assert!(header_content.contains("STM32_TARGET"));

        // Should have main.c example file
        assert!(result.example_file.is_some());
        let main_path = result.example_file.unwrap();
        assert!(main_path.contains("main.c"));

        // Verify main.c file exists and has correct content
        let main_content = std::fs::read_to_string(&main_path).unwrap();
        assert!(main_content.contains("#include \"blitzed_model.h\""));
        assert!(main_content.contains("int main(void)"));
        assert!(main_content.contains("HAL_Init()"));
        assert!(main_content.contains("model_predict"));
        assert!(main_content.contains("printf"));
        assert!(main_content.contains("SystemClock_Config"));

        // Should have makefile for STM32
        assert!(result.build_config.is_some());
    }

    #[test]
    fn test_stm32_target_compatibility() {
        let model = create_test_model();
        let stm32_target = crate::targets::stm32::Stm32Target::new();

        // STM32 has more memory than Arduino
        let constraints = stm32_target.constraints();
        assert_eq!(constraints.memory_limit, 128 * 1024); // 128KB RAM
        assert_eq!(constraints.storage_limit, 1024 * 1024); // 1MB Flash
        assert!(constraints.has_fpu); // Many STM32 have FPU
        assert_eq!(constraints.architecture, "ARM Cortex-M");

        // Test model should fit comfortably
        assert!(model.info().model_size_bytes < constraints.storage_limit);
    }

    #[test]
    fn test_stm32_optimization_strategy() {
        let stm32_target = crate::targets::stm32::Stm32Target::new();
        let strategy = stm32_target.optimization_strategy();

        // STM32 needs optimization but can handle more complex models than Arduino
        assert!(strategy.aggressive_quantization);
        assert!(strategy.enable_pruning);
        assert_eq!(strategy.target_precision, "int8"); // Standard INT8
        assert!(strategy.memory_optimization);
        assert!(strategy.speed_optimization); // Can leverage FPU
    }
}
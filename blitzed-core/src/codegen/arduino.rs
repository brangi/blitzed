// Copyright 2025 Gibran Rodriguez <brangi000@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Arduino-specific code generator

use super::{CodeGenerator, GeneratedCode};
use crate::{Model, Result};
use std::path::Path;

/// Arduino code generator that wraps the C code generator with Arduino-specific features
pub struct ArduinoCodeGen {
    c_generator: super::c::CCodeGen,
}

impl ArduinoCodeGen {
    #[must_use]
    pub fn new() -> Self {
        Self {
            c_generator: super::c::CCodeGen::with_target("arduino"),
        }
    }
}

impl CodeGenerator for ArduinoCodeGen {
    fn generate(&self, model: &Model, output_dir: &Path) -> Result<GeneratedCode> {
        std::fs::create_dir_all(output_dir)?;

        // First, generate the C code using the C generator
        let c_result = self.c_generator.generate(model, output_dir)?;

        // Generate Arduino-specific .ino file
        let ino_content = format!(
            r#"// Generated by Blitzed v{}
// Arduino model deployment

#include "blitzed_model.h"

void setup() {{
    Serial.begin(9600);
    Serial.println("Blitzed Model on Arduino");
    
    if (model_init() != 0) {{
        Serial.println("Error: Model initialization failed");
        return;
    }}
    
    Serial.println("Model initialized successfully");
}}

void loop() {{
    // Example inference every 5 seconds
    static unsigned long lastRun = 0;
    unsigned long currentTime = millis();
    
    if (currentTime - lastRun >= 5000) {{
        runInference();
        lastRun = currentTime;
    }}
}}

void runInference() {{
    model_input_t input[MODEL_INPUT_SIZE];
    model_output_t output[MODEL_OUTPUT_SIZE];
    
    // Generate sample input data
    for (int i = 0; i < MODEL_INPUT_SIZE; i++) {{
        input[i] = (model_input_t)(random(256) - 128);
    }}
    
    Serial.println("Running inference...");
    unsigned long start = millis();
    
    if (model_predict(input, output) == 0) {{
        unsigned long duration = millis() - start;
        Serial.print("Inference completed in ");
        Serial.print(duration);
        Serial.println(" ms");
        
        // Print top result
        Serial.print("Top output: ");
        Serial.println(output[0]);
    }} else {{
        Serial.println("Inference failed");
    }}
}}
"#,
            crate::VERSION
        );

        let ino_path = output_dir.join("blitzed_model.ino");
        std::fs::write(&ino_path, &ino_content)?;

        // Return both C files and Arduino .ino file
        Ok(GeneratedCode {
            implementation_file: c_result.implementation_file,
            header_file: c_result.header_file,
            example_file: Some(ino_path.to_string_lossy().to_string()),
            build_config: None, // Arduino uses IDE, not makefiles
            dependencies: vec!["Arduino IDE".to_string(), "Arduino AVR Boards".to_string()],
        })
    }

    fn target_name(&self) -> &'static str {
        "arduino"
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["Arduino IDE".to_string()]
    }
}

impl Default for ArduinoCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::{Model, ModelData, ModelFormat, ModelInfo};
    use crate::targets::HardwareTarget;
    use tempfile::TempDir;

    fn create_test_model() -> Model {
        let info = ModelInfo {
            format: ModelFormat::Onnx,
            input_shapes: vec![vec![1, 10]], // Small input for Arduino
            output_shapes: vec![vec![1, 2]], // Binary classification
            parameter_count: 100,            // Very small model
            model_size_bytes: 400,           // 400 bytes - fits in Arduino
            operations_count: 50,            // Minimal operations
            layers: vec![],                  // Empty for test
        };

        Model {
            info,
            data: ModelData::Raw(vec![0u8; 400]),
        }
    }

    #[test]
    fn test_arduino_codegen_creation() {
        let codegen = ArduinoCodeGen::new();
        assert_eq!(codegen.target_name(), "arduino");
        assert!(codegen.dependencies().contains(&"Arduino IDE".to_string()));
    }

    #[test]
    fn test_arduino_code_generation() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("arduino_output");
        
        let model = create_test_model();
        let codegen = ArduinoCodeGen::new();
        let result = codegen.generate(&model, &output_dir).unwrap();

        // Should have C implementation and header files
        assert!(result.header_file.is_some());
        let header_content = std::fs::read_to_string(result.header_file.as_ref().unwrap()).unwrap();
        assert!(header_content.contains("ARDUINO_TARGET"));
        
        // Should have .ino example file
        assert!(result.example_file.is_some());
        let ino_path = result.example_file.unwrap();
        assert!(ino_path.contains("blitzed_model.ino"));
        
        // Verify .ino file exists and has correct content
        let ino_content = std::fs::read_to_string(&ino_path).unwrap();
        assert!(ino_content.contains("#include \"blitzed_model.h\""));
        assert!(ino_content.contains("void setup()"));
        assert!(ino_content.contains("void loop()"));
        assert!(ino_content.contains("model_predict"));
        assert!(ino_content.contains("Serial"));
        
        // No makefile for Arduino (uses IDE)
        assert!(result.build_config.is_none());
    }

    #[test]
    fn test_arduino_target_compatibility() {
        let model = create_test_model();
        let arduino_target = crate::targets::arduino::ArduinoTarget::new();
        
        // Arduino has very limited memory, should work with tiny models
        let constraints = arduino_target.constraints();
        assert_eq!(constraints.memory_limit, 2 * 1024); // 2KB RAM
        assert_eq!(constraints.storage_limit, 32 * 1024); // 32KB Flash
        assert!(!constraints.has_fpu);
        assert_eq!(constraints.architecture, "AVR");
        
        // Test model should be small enough
        assert!(model.info().model_size_bytes < constraints.storage_limit);
    }

    #[test]
    fn test_arduino_optimization_strategy() {
        let arduino_target = crate::targets::arduino::ArduinoTarget::new();
        let strategy = arduino_target.optimization_strategy();
        
        // Arduino needs very aggressive optimization
        assert!(strategy.aggressive_quantization);
        assert!(strategy.enable_pruning);
        assert_eq!(strategy.target_precision, "int4"); // Even more aggressive than INT8
        assert!(strategy.memory_optimization);
        assert!(!strategy.speed_optimization); // Size over speed
    }
}

// Copyright 2025 Gibran Rodriguez <brangi000@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Generic C code generator for edge deployment

use super::{CodeGenerator, GeneratedCode};
use crate::{Model, Result};
use std::path::Path;

/// Generic C code generator
pub struct CCodeGen;

impl CCodeGen {
    pub fn new() -> Self {
        Self
    }

    fn generate_header(&self, _model: &Model) -> String {
        format!(
            r#"// Generated by Blitzed v{}
// Edge AI model deployment code

#ifndef BLITZED_MODEL_H
#define BLITZED_MODEL_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {{
#endif

// Model configuration
#define MODEL_INPUT_SIZE 224*224*3
#define MODEL_OUTPUT_SIZE 1000
#define MODEL_QUANTIZED 1

// Data types
typedef int8_t model_weight_t;
typedef int32_t model_bias_t;
typedef int8_t model_input_t;
typedef int8_t model_output_t;

// Function declarations
int model_init(void);
int model_predict(const model_input_t* input, model_output_t* output);
void model_cleanup(void);

// Quantization helpers
model_input_t quantize_input(float value);
float dequantize_output(model_output_t value);

#ifdef __cplusplus
}}
#endif

#endif // BLITZED_MODEL_H
"#,
            crate::VERSION
        )
    }

    fn generate_implementation(&self, _model: &Model) -> String {
        format!(
            r#"// Generated by Blitzed v{}
// Edge AI model implementation

#include "blitzed_model.h"
#include <string.h>

// Model weights (quantized)
static const model_weight_t model_weights[] = {{
    // TODO: Insert actual quantized weights
    0, 1, -1, 2, -2  // Placeholder
}};

// Model biases
static const model_bias_t model_biases[] = {{
    // TODO: Insert actual biases
    0, 100, -100  // Placeholder
}};

// Quantization parameters
static const float input_scale = 0.0078125f;  // 1/128
static const int input_zero_point = 128;
static const float output_scale = 0.1f;
static const int output_zero_point = 0;

int model_init(void) {{
    // Initialize model state if needed
    return 0;  // Success
}}

int model_predict(const model_input_t* input, model_output_t* output) {{
    if (input == NULL || output == NULL) {{
        return -1;  // Error: null pointer
    }}
    
    // TODO: Implement actual inference
    // This is a placeholder implementation
    memset(output, 0, MODEL_OUTPUT_SIZE * sizeof(model_output_t));
    
    // Simple mock inference
    for (int i = 0; i < MODEL_OUTPUT_SIZE && i < 5; i++) {{
        output[i] = (model_output_t)(input[i] * 2);
    }}
    
    return 0;  // Success
}}

void model_cleanup(void) {{
    // Cleanup if needed
}}

model_input_t quantize_input(float value) {{
    int quantized = (int)(value / input_scale) + input_zero_point;
    if (quantized < -128) quantized = -128;
    if (quantized > 127) quantized = 127;
    return (model_input_t)quantized;
}}

float dequantize_output(model_output_t value) {{
    return (value - output_zero_point) * output_scale;
}}
"#,
            crate::VERSION
        )
    }

    fn generate_example(&self) -> String {
        format!(
            r#"// Generated by Blitzed v{}
// Example usage of the generated model

#include "blitzed_model.h"
#include <stdio.h>
#include <stdlib.h>

int main() {{
    printf("Blitzed Model Example\n");
    printf("====================\n");

    // Initialize model
    if (model_init() != 0) {{
        printf("Error: Failed to initialize model\n");
        return -1;
    }}

    // Prepare input data (example: random values)
    model_input_t* input = (model_input_t*)malloc(MODEL_INPUT_SIZE * sizeof(model_input_t));
    model_output_t* output = (model_output_t*)malloc(MODEL_OUTPUT_SIZE * sizeof(model_output_t));
    
    if (input == NULL || output == NULL) {{
        printf("Error: Failed to allocate memory\n");
        return -1;
    }}

    // Fill input with example data
    for (int i = 0; i < MODEL_INPUT_SIZE; i++) {{
        input[i] = quantize_input((float)(i % 255) / 255.0f);
    }}

    // Run inference
    printf("Running inference...\n");
    if (model_predict(input, output) != 0) {{
        printf("Error: Inference failed\n");
        free(input);
        free(output);
        return -1;
    }}

    // Print results
    printf("Top 5 outputs:\n");
    for (int i = 0; i < 5 && i < MODEL_OUTPUT_SIZE; i++) {{
        float dequantized = dequantize_output(output[i]);
        printf("  Output[%d]: %d (%.4f)\n", i, output[i], dequantized);
    }}

    // Cleanup
    free(input);
    free(output);
    model_cleanup();

    printf("Example completed successfully!\n");
    return 0;
}}
"#,
            crate::VERSION
        )
    }

    fn generate_makefile(&self) -> String {
        format!(
            r#"# Generated by Blitzed v{}
# Makefile for compiled model

CC = gcc
CFLAGS = -Wall -Wextra -O3 -std=c99
TARGET = blitzed_model_example
SOURCES = blitzed_model.c example.c
OBJECTS = $(SOURCES:.c=.o)

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJECTS) $(TARGET)

install: $(TARGET)
	mkdir -p /usr/local/bin
	cp $(TARGET) /usr/local/bin/

.PHONY: test
test: $(TARGET)
	./$(TARGET)
"#,
            crate::VERSION
        )
    }
}

impl CodeGenerator for CCodeGen {
    fn generate(&self, model: &Model, output_dir: &Path) -> Result<GeneratedCode> {
        std::fs::create_dir_all(output_dir)?;

        let header_content = self.generate_header(model);
        let impl_content = self.generate_implementation(model);
        let example_content = self.generate_example();
        let makefile_content = self.generate_makefile();

        let header_path = output_dir.join("blitzed_model.h");
        let impl_path = output_dir.join("blitzed_model.c");
        let example_path = output_dir.join("example.c");
        let makefile_path = output_dir.join("Makefile");

        std::fs::write(&header_path, header_content)?;
        std::fs::write(&impl_path, &impl_content)?;
        std::fs::write(&example_path, &example_content)?;
        std::fs::write(&makefile_path, &makefile_content)?;

        Ok(GeneratedCode {
            implementation_file: impl_content,
            header_file: Some(header_path.to_string_lossy().to_string()),
            example_file: Some(example_path.to_string_lossy().to_string()),
            build_config: Some(makefile_path.to_string_lossy().to_string()),
            dependencies: vec!["gcc".to_string()],
        })
    }

    fn target_name(&self) -> &str {
        "c"
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["gcc".to_string()]
    }
}

impl Default for CCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

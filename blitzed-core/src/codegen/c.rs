// Copyright 2025 Gibran Rodriguez <brangi000@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Generic C code generator for edge deployment

use super::{CodeGenerator, GeneratedCode};
use crate::{Model, Result};
use std::path::Path;

/// Generic C code generator with hardware-aware optimizations
pub struct CCodeGen {
    target_name: String,
}

impl CCodeGen {
    pub fn new() -> Self {
        Self {
            target_name: "generic".to_string(),
        }
    }

    pub fn with_target(target: &str) -> Self {
        Self {
            target_name: target.to_string(),
        }
    }

    fn generate_header(&self, model: &Model) -> String {
        let model_info = model.info();

        // Calculate input/output sizes
        let input_size: i64 = model_info
            .input_shapes
            .first()
            .map(|shape| shape.iter().product())
            .unwrap_or(1);
        let output_size: i64 = model_info
            .output_shapes
            .first()
            .map(|shape| shape.iter().product())
            .unwrap_or(1);

        // Get target-specific configuration
        let target_config = self.get_target_config();

        format!(
            r#"// Generated by Blitzed v{}
// Edge AI model deployment code for {}
// Model: {} parameters, {} operations

#ifndef BLITZED_MODEL_H
#define BLITZED_MODEL_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {{
#endif

// Model configuration
#define MODEL_INPUT_SIZE {}
#define MODEL_OUTPUT_SIZE {}
#define MODEL_PARAM_COUNT {}
#define MODEL_QUANTIZED 1
#define TARGET_PLATFORM "{}"

// Hardware configuration
{}

// Data types (INT8 quantized)
typedef int8_t model_weight_t;
typedef int32_t model_bias_t;
typedef int8_t model_input_t;
typedef int8_t model_output_t;
typedef int32_t model_accumulator_t;

// Model structure
typedef struct {{
    const model_weight_t* weights;
    const model_bias_t* biases;
    uint32_t num_layers;
    uint32_t param_count;
}} blitzed_model_t;

// Function declarations
int model_init(void);
int model_predict(const model_input_t* input, model_output_t* output);
void model_cleanup(void);

// Quantization helpers
model_input_t quantize_input(float value);
float dequantize_output(model_output_t value);

// Performance monitoring
uint32_t model_get_inference_time_us(void);
uint32_t model_get_memory_usage(void);

#ifdef __cplusplus
}}
#endif

#endif // BLITZED_MODEL_H
"#,
            crate::VERSION,
            self.target_name,
            model_info.parameter_count,
            model_info.operations_count,
            input_size,
            output_size,
            model_info.parameter_count,
            self.target_name.to_uppercase(),
            target_config
        )
    }

    fn get_target_config(&self) -> String {
        match self.target_name.as_str() {
            "esp32" => "#define ESP32_TARGET 1\n#define USE_PSRAM 0\n#define OPTIMIZE_FOR_SIZE 1"
                .to_string(),
            "raspberry_pi" => {
                "#define RPI_TARGET 1\n#define USE_NEON 1\n#define OPTIMIZE_FOR_SPEED 1".to_string()
            }
            _ => "#define GENERIC_TARGET 1".to_string(),
        }
    }

    fn generate_implementation(&self, model: &Model) -> String {
        let model_info = model.info();
        let weights_data = self.serialize_weights(model);

        format!(
            r#"// Generated by Blitzed v{}
// Edge AI model implementation for {}

#include "blitzed_model.h"
#include <string.h>
#include <stdlib.h>

#ifdef ESP32_TARGET
#include "esp_timer.h"
#elif defined(RPI_TARGET)
#include <time.h>
#endif

// Model weights (INT8 quantized)
static const model_weight_t model_weights[] = {{
{}
}};

// Model biases (INT32)
static const model_bias_t model_biases[] = {{
    0, 128, -64, 256, -128, 512, -256, 1024, -512, 2048
}};

// Quantization parameters
static const float input_scale = 0.0078125f;  // 1/128 for INT8
static const int32_t input_zero_point = 0;
static const float output_scale = 0.00390625f;  // 1/256
static const int32_t output_zero_point = 0;

// Performance tracking
static uint32_t last_inference_time_us = 0;
static uint32_t total_memory_usage = {};

// Model instance
static blitzed_model_t model_instance = {{
    .weights = model_weights,
    .biases = model_biases,
    .num_layers = {},
    .param_count = {}
}};

int model_init(void) {{
    #ifdef ESP32_TARGET
        // ESP32-specific initialization for memory optimization
    #elif defined(RPI_TARGET)
        // Raspberry Pi initialization for performance
    #endif
    
    return 0;  // Success
}}

int model_predict(const model_input_t* input, model_output_t* output) {{
    if (input == NULL || output == NULL) {{
        return -1;  // Error: null pointer
    }}
    
    #ifdef ESP32_TARGET
        int64_t start_time = esp_timer_get_time();
    #elif defined(RPI_TARGET)
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
    #else
        uint32_t start_time = 0;
    #endif
    
    // Simplified inference - in reality this would be layer-by-layer processing
    // Initialize output
    memset(output, 0, MODEL_OUTPUT_SIZE * sizeof(model_output_t));
    
    // Example quantized inference computation
    for (int out = 0; out < MODEL_OUTPUT_SIZE && out < 10; out++) {{
        model_accumulator_t acc = model_instance.biases[out % 10];
        
        // Simulate matrix multiplication with quantized values
        for (int in = 0; in < 100 && in < MODEL_INPUT_SIZE; in++) {{
            int weight_idx = (out * 100 + in) % (sizeof(model_weights)/sizeof(model_weights[0]));
            acc += (model_accumulator_t)input[in] * (model_accumulator_t)model_weights[weight_idx];
        }}
        
        // Quantize back to INT8 with ReLU activation
        acc = acc >> 8;  // Scale down from accumulator
        if (acc < 0) acc = 0;      // ReLU activation
        if (acc > 127) acc = 127;  // Clip to INT8 range
        if (acc < -128) acc = -128;
        
        output[out] = (model_output_t)acc;
    }}
    
    #ifdef ESP32_TARGET
        last_inference_time_us = (uint32_t)(esp_timer_get_time() - start_time);
    #elif defined(RPI_TARGET)
        clock_gettime(CLOCK_MONOTONIC, &end);
        last_inference_time_us = (end.tv_sec - start.tv_sec) * 1000000 + 
                                 (end.tv_nsec - start.tv_nsec) / 1000;
    #endif
    
    return 0;  // Success
}}

void model_cleanup(void) {{
    // Cleanup resources if needed
}}

model_input_t quantize_input(float value) {{
    int32_t quantized = (int32_t)(value / input_scale) + input_zero_point;
    if (quantized < -128) quantized = -128;
    if (quantized > 127) quantized = 127;
    return (model_input_t)quantized;
}}

float dequantize_output(model_output_t value) {{
    return ((float)value - output_zero_point) * output_scale;
}}

uint32_t model_get_inference_time_us(void) {{
    return last_inference_time_us;
}}

uint32_t model_get_memory_usage(void) {{
    return total_memory_usage;
}}
"#,
            crate::VERSION,
            self.target_name,
            weights_data,
            model_info.model_size_bytes,
            model_info.layers.len(),
            model_info.parameter_count
        )
    }

    fn serialize_weights(&self, model: &Model) -> String {
        // Generate sample quantized weights based on model parameters
        let mut weights = Vec::new();
        let param_count = model.info().parameter_count.min(1000); // Limit for demo

        for i in 0..param_count {
            if i % 16 == 0 {
                weights.push("\n    ".to_string());
            }
            // Generate pseudo-random INT8 weights
            let weight = (((i * 7 + 13) % 255) as i8).wrapping_sub(127);
            weights.push(format!("{}, ", weight));
        }

        if weights.is_empty() {
            "    0, 1, -1, 2, -2  // Minimal weights".to_string()
        } else {
            weights.join("") + "\n    // End of weights"
        }
    }

    fn generate_example(&self) -> String {
        format!(
            r#"// Generated by Blitzed v{}
// Example usage of the generated model

#include "blitzed_model.h"
#include <stdio.h>
#include <stdlib.h>

int main() {{
    printf("Blitzed Model Example\n");
    printf("====================\n");

    // Initialize model
    if (model_init() != 0) {{
        printf("Error: Failed to initialize model\n");
        return -1;
    }}

    // Prepare input data (example: random values)
    model_input_t* input = (model_input_t*)malloc(MODEL_INPUT_SIZE * sizeof(model_input_t));
    model_output_t* output = (model_output_t*)malloc(MODEL_OUTPUT_SIZE * sizeof(model_output_t));
    
    if (input == NULL || output == NULL) {{
        printf("Error: Failed to allocate memory\n");
        return -1;
    }}

    // Fill input with example data
    for (int i = 0; i < MODEL_INPUT_SIZE; i++) {{
        input[i] = quantize_input((float)(i % 255) / 255.0f);
    }}

    // Run inference
    printf("Running inference...\n");
    if (model_predict(input, output) != 0) {{
        printf("Error: Inference failed\n");
        free(input);
        free(output);
        return -1;
    }}

    // Print results
    printf("Top 5 outputs:\n");
    for (int i = 0; i < 5 && i < MODEL_OUTPUT_SIZE; i++) {{
        float dequantized = dequantize_output(output[i]);
        printf("  Output[%d]: %d (%.4f)\n", i, output[i], dequantized);
    }}

    // Cleanup
    free(input);
    free(output);
    model_cleanup();

    printf("Example completed successfully!\n");
    return 0;
}}
"#,
            crate::VERSION
        )
    }

    fn generate_makefile(&self) -> String {
        let (cc, cflags, libs) = match self.target_name.as_str() {
            "esp32" => (
                "xtensa-esp32-elf-gcc",
                "-Wall -Wextra -O3 -std=c99 -DESP32_TARGET -ffunction-sections -fdata-sections",
                "-lm"
            ),
            "raspberry_pi" => (
                "gcc", 
                "-Wall -Wextra -O3 -std=c99 -DRPI_TARGET -march=armv8-a -mtune=cortex-a72 -mfpu=neon-fp-armv8",
                "-lm -lrt"
            ),
            _ => (
                "gcc",
                "-Wall -Wextra -O3 -std=c99 -DGENERIC_TARGET",
                "-lm"
            )
        };

        format!(
            r#"# Generated by Blitzed v{}
# Makefile for {} target

CC = {}
CFLAGS = {}
LIBS = {}
TARGET = blitzed_model_example
SOURCES = blitzed_model.c example.c
OBJECTS = $(SOURCES:.c=.o)

.PHONY: all clean test

all: $(TARGET)

$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET) $(LIBS)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJECTS) $(TARGET)

# Hardware-specific targets
{}

test: $(TARGET)
	./$(TARGET)
"#,
            crate::VERSION,
            self.target_name,
            cc,
            cflags,
            libs,
            self.generate_hardware_specific_targets()
        )
    }

    fn generate_hardware_specific_targets(&self) -> String {
        match self.target_name.as_str() {
            "esp32" => r#"flash: $(TARGET)
	esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 $(TARGET).bin

monitor:
	screen /dev/ttyUSB0 115200"#
                .to_string(),
            "raspberry_pi" => r#"deploy: $(TARGET)
	scp $(TARGET) pi@raspberrypi.local:~/
	ssh pi@raspberrypi.local chmod +x $(TARGET)

run-remote: deploy
	ssh pi@raspberrypi.local ./$(TARGET)"#
                .to_string(),
            _ => "# No hardware-specific targets".to_string(),
        }
    }
}

impl CodeGenerator for CCodeGen {
    fn generate(&self, model: &Model, output_dir: &Path) -> Result<GeneratedCode> {
        std::fs::create_dir_all(output_dir)?;

        let header_content = self.generate_header(model);
        let impl_content = self.generate_implementation(model);
        let example_content = self.generate_example();
        let makefile_content = self.generate_makefile();

        let header_path = output_dir.join("blitzed_model.h");
        let impl_path = output_dir.join("blitzed_model.c");
        let example_path = output_dir.join("example.c");
        let makefile_path = output_dir.join("Makefile");

        std::fs::write(&header_path, header_content)?;
        std::fs::write(&impl_path, &impl_content)?;
        std::fs::write(&example_path, &example_content)?;
        std::fs::write(&makefile_path, &makefile_content)?;

        Ok(GeneratedCode {
            implementation_file: impl_content,
            header_file: Some(header_path.to_string_lossy().to_string()),
            example_file: Some(example_path.to_string_lossy().to_string()),
            build_config: Some(makefile_path.to_string_lossy().to_string()),
            dependencies: vec!["gcc".to_string()],
        })
    }

    fn target_name(&self) -> &str {
        "c"
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["gcc".to_string()]
    }
}

impl Default for CCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::{LayerInfo, Model, ModelData, ModelFormat, ModelInfo};
    use std::fs;
    use tempfile::tempdir;

    fn create_test_model() -> Model {
        let info = ModelInfo {
            format: ModelFormat::Onnx,
            input_shapes: vec![vec![1, 3, 32, 32]],
            output_shapes: vec![vec![1, 10]],
            parameter_count: 50000,
            model_size_bytes: 200000, // 200KB
            operations_count: 100000,
            layers: vec![
                LayerInfo {
                    name: "conv1".to_string(),
                    layer_type: "Conv2d".to_string(),
                    input_shape: vec![1, 3, 32, 32],
                    output_shape: vec![1, 64, 16, 16],
                    parameter_count: 1728,
                    flops: 1769472,
                },
                LayerInfo {
                    name: "fc".to_string(),
                    layer_type: "Linear".to_string(),
                    input_shape: vec![1, 1024],
                    output_shape: vec![1, 10],
                    parameter_count: 10240,
                    flops: 20480,
                },
            ],
        };

        Model {
            info,
            data: ModelData::Raw(vec![0u8; 1000]),
        }
    }

    #[test]
    fn test_c_codegen_creation() {
        let codegen = CCodeGen::new();
        assert_eq!(codegen.target_name, "generic");

        let esp32_codegen = CCodeGen::with_target("esp32");
        assert_eq!(esp32_codegen.target_name, "esp32");
    }

    #[test]
    fn test_header_generation() {
        let codegen = CCodeGen::with_target("esp32");
        let model = create_test_model();
        let header = codegen.generate_header(&model);

        assert!(header.contains("#ifndef BLITZED_MODEL_H"));
        assert!(header.contains("ESP32_TARGET"));
        assert!(header.contains("MODEL_INPUT_SIZE 3072")); // 1*3*32*32
        assert!(header.contains("MODEL_OUTPUT_SIZE 10"));
        assert!(header.contains("50000")); // parameter count
    }

    #[test]
    fn test_implementation_generation() {
        let codegen = CCodeGen::with_target("raspberry_pi");
        let model = create_test_model();
        let impl_code = codegen.generate_implementation(&model);

        assert!(impl_code.contains("#include \"blitzed_model.h\""));
        assert!(impl_code.contains("model_weights[]"));
        assert!(impl_code.contains("model_predict"));
        assert!(impl_code.contains("RPI_TARGET"));
        assert!(impl_code.contains("clock_gettime"));
    }

    #[test]
    fn test_weight_serialization() {
        let codegen = CCodeGen::new();
        let model = create_test_model();
        let weights = codegen.serialize_weights(&model);

        assert!(!weights.is_empty());
        assert!(weights.contains(","));
        assert!(weights.contains("End of weights"));
    }

    #[test]
    fn test_makefile_generation_esp32() {
        let codegen = CCodeGen::with_target("esp32");
        let makefile = codegen.generate_makefile();

        assert!(makefile.contains("xtensa-esp32-elf-gcc"));
        assert!(makefile.contains("-DESP32_TARGET"));
        assert!(makefile.contains("flash:"));
        assert!(makefile.contains("esptool.py"));
    }

    #[test]
    fn test_makefile_generation_raspberry_pi() {
        let codegen = CCodeGen::with_target("raspberry_pi");
        let makefile = codegen.generate_makefile();

        assert!(makefile.contains("-DRPI_TARGET"));
        assert!(makefile.contains("-march=armv8-a"));
        assert!(makefile.contains("deploy:"));
        assert!(makefile.contains("scp"));
    }

    #[test]
    fn test_full_code_generation() {
        let temp_dir = tempdir().unwrap();
        let codegen = CCodeGen::with_target("esp32");
        let model = create_test_model();

        let result = codegen.generate(&model, temp_dir.path()).unwrap();

        // Verify all files are generated
        let header_path = temp_dir.path().join("blitzed_model.h");
        let impl_path = temp_dir.path().join("blitzed_model.c");
        let example_path = temp_dir.path().join("example.c");
        let makefile_path = temp_dir.path().join("Makefile");

        assert!(header_path.exists());
        assert!(impl_path.exists());
        assert!(example_path.exists());
        assert!(makefile_path.exists());

        // Verify content
        let header_content = fs::read_to_string(&header_path).unwrap();
        assert!(header_content.contains("ESP32_TARGET"));

        let impl_content = fs::read_to_string(&impl_path).unwrap();
        assert!(impl_content.contains("esp_timer.h"));

        // Verify result structure
        assert!(!result.implementation_file.is_empty());
        assert!(result.header_file.is_some());
        assert!(result.example_file.is_some());
        assert!(result.build_config.is_some());
        assert!(!result.dependencies.is_empty());
    }

    #[test]
    fn test_hardware_target_config() {
        let esp32_codegen = CCodeGen::with_target("esp32");
        let esp32_config = esp32_codegen.get_target_config();
        assert!(esp32_config.contains("ESP32_TARGET 1"));
        assert!(esp32_config.contains("OPTIMIZE_FOR_SIZE 1"));

        let rpi_codegen = CCodeGen::with_target("raspberry_pi");
        let rpi_config = rpi_codegen.get_target_config();
        assert!(rpi_config.contains("RPI_TARGET 1"));
        assert!(rpi_config.contains("OPTIMIZE_FOR_SPEED 1"));
    }

    #[test]
    fn test_code_generator_interface() {
        let codegen = CCodeGen::new();
        assert_eq!(codegen.target_name(), "c");
        assert!(!codegen.dependencies().is_empty());
        assert!(codegen.dependencies().contains(&"gcc".to_string()));
    }
}
